# Глава 5: Массивы и слайсы

## Введение

В Go есть два способа работы с последовательностями элементов:
- **Массивы (arrays)** — фиксированная длина
- **Слайсы (slices)** — динамическая длина (используются чаще всего)

**Сравнение с Java:**
- Массив Go `[5]int` ≈ Java `int[5]` (но размер — часть типа!)
- Слайс Go `[]int` ≈ Java `ArrayList<Integer>`

---

## Массивы (Arrays)

### Определение

Массив — это фиксированная последовательность элементов **одного типа**. Размер массива является **частью его типа**.

```go
var arr [5]int  // массив из 5 int, все элементы инициализированы нулями
fmt.Println(arr) // [0 0 0 0 0]

// Инициализация с значениями
numbers := [3]int{1, 2, 3}

// Автоматический подсчёт длины
primes := [...]int{2, 3, 5, 7, 11} // компилятор вычислит: [5]int
```

### Ключевое отличие от Java

В Java:
```java
int[] arr = new int[5];  // тип: int[] (массив любой длины)
```

В Go:
```go
var a [5]int   // тип: [5]int
var b [10]int  // тип: [10]int — ДРУГОЙ ТИП!
```

`[5]int` и `[10]int` — это **разные типы**, их нельзя присвоить друг другу или передать в функцию, ожидающую другой размер.

### Передача по значению

Массивы в Go передаются **по значению** (копируются целиком):

```go
func modifyArray(arr [3]int) {
    arr[0] = 999 // меняем локальную копию
}

numbers := [3]int{1, 2, 3}
modifyArray(numbers)
fmt.Println(numbers) // [1 2 3] — оригинал не изменился!
```

**Сравнение с Java:** В Java массивы — это reference types, передаются по ссылке.

---

## Слайсы (Slices)

### Что такое слайс?

**Слайс — это динамический view (представление) над массивом**. Это самая часто используемая структура данных в Go для работы с последовательностями.

Внутри слайс содержит:
- **Указатель** на базовый массив
- **Length (длина)** — количество элементов
- **Capacity (ёмкость)** — размер базового массива от начала слайса

```go
// Создание слайса
var s []int  // nil слайс, length=0, capacity=0
fmt.Println(s == nil) // true

// Создание с make
s = make([]int, 5)     // length=5, capacity=5, все элементы = 0
s = make([]int, 3, 10) // length=3, capacity=10

// Литерал слайса (как массив, но без размера в [])
nums := []int{1, 2, 3, 4, 5}
```

### Length и Capacity

```go
s := make([]int, 3, 10)
fmt.Println(len(s)) // 3  — текущее количество элементов
fmt.Println(cap(s)) // 10 — размер базового массива (доступно для роста)
```

**Аналогия с Java:**
- `len(s)` ≈ `list.size()`
- `cap(s)` ≈ внутренний размер массива в `ArrayList` (не exposed в API)

---

## Операции со слайсами

### Append — добавление элементов

```go
var s []int // nil слайс
s = append(s, 1)        // [1]
s = append(s, 2, 3, 4)  // [1 2 3 4]

// Добавление другого слайса (оператор ...)
more := []int{5, 6}
s = append(s, more...)  // [1 2 3 4 5 6]
```

**Важно:** `append` возвращает **новый слайс** (может быть тот же или новый, если потребовалась реаллокация). Всегда присваивай результат:

```go
s = append(s, 10) // ✅ Правильно
append(s, 10)     // ❌ Неправильно — результат потерян
```

**Сравнение с Java:**
```java
list.add(10);           // изменяет объект
s = append(s, 10)       // возвращает (возможно новый) слайс
```

### Slicing — получение подслайса

Синтаксис: `s[low:high]` (от `low` включительно до `high` НЕ включая)

```go
nums := []int{0, 1, 2, 3, 4, 5}

slice1 := nums[1:4]  // [1 2 3]
slice2 := nums[:3]   // [0 1 2] (от начала)
slice3 := nums[3:]   // [3 4 5] (до конца)
slice4 := nums[:]    // [0 1 2 3 4 5] (полная копия view)
```

**⚠️ Важно:** Подслайс ссылается на **тот же базовый массив**:

```go
nums := []int{0, 1, 2, 3, 4}
sub := nums[1:4] // [1 2 3]

sub[0] = 999
fmt.Println(nums) // [0 999 2 3 4] — оригинал изменился!
```

**Сравнение с Java:** `List.subList()` тоже возвращает view, а не копию.

### Copy — независимое копирование

Чтобы создать **независимую копию**, используй `copy`:

```go
src := []int{1, 2, 3}
dst := make([]int, len(src))
copy(dst, src)  // копирует элементы из src в dst

dst[0] = 999
fmt.Println(src) // [1 2 3] — не изменился
fmt.Println(dst) // [999 2 3]
```

**Сравнение с Java:**
```java
List<Integer> copy = new ArrayList<>(original);
```

---

## Итерация с range

```go
nums := []int{10, 20, 30}

// С индексом и значением
for i, v := range nums {
    fmt.Printf("nums[%d] = %d\n", i, v)
}

// Только значение (игнорируем индекс через _)
for _, v := range nums {
    fmt.Println(v)
}

// Только индекс
for i := range nums {
    fmt.Println(i)
}
```

**Сравнение с Java:**
```java
// Java enhanced for
for (int v : nums) { }

// Java Stream
nums.stream().forEach(v -> ...)
```

---

## Стратегия роста capacity

Когда `append` не влезает в текущий capacity, Go создаёт **новый базовый массив** с увеличенной ёмкостью:

**Стратегия (Go 1.18+):**
- **capacity < 256**: удваивается (×2)
- **capacity >= 256**: растёт примерно на 25% (×1.25)

**Сравнение с Java ArrayList:**
- Java: всегда увеличивает на 50% (×1.5)
- Go: агрессивнее для маленьких, медленнее для больших

Пример:
```go
s := make([]int, 0, 1)
// cap: 1 → 2 → 4 → 8 → 16 → 32 → 64 → 128 → 256 → 512 → ~640 → ~800 ...
```

---

## Подводные камни

### ⚠️ Камень #1: Slicing и утечки памяти

```go
func processLargeFile() []byte {
    data := make([]byte, 10_000_000) // 10 MB
    // ... читаем файл в data ...

    return data[:10] // ❌ УТЕЧКА! базовый массив 10MB остаётся в памяти
}
```

**Проблема:** Подслайс держит ссылку на весь базовый массив (10MB), хотя используется только 10 байт.

**Решение:**
```go
func processLargeFile() []byte {
    data := make([]byte, 10_000_000)
    // ... читаем файл ...

    result := make([]byte, 10)
    copy(result, data[:10]) // ✅ Независимая копия
    return result           // data может быть освобождён GC
}
```

### ⚠️ Камень #2: Append может перезаписать другие слайсы

```go
original := []int{1, 2, 3, 4, 5}
slice1 := original[:3]  // [1 2 3], cap=5
slice2 := original[2:5] // [3 4 5], cap=3

slice1 = append(slice1, 999) // влезает в capacity!

fmt.Println(original) // [1 2 3 999 5] — изменился!
fmt.Println(slice2)   // [999 5] — тоже изменился!
```

**Решение:** Используй **full slice expression** `[low:high:max]` чтобы ограничить capacity:

```go
slice1 := original[:3:3] // length=3, capacity=3 (не может расти в старый массив)
slice1 = append(slice1, 999) // создаст новый массив
```

### ⚠️ Камень #3: nil slice vs empty slice

```go
var s1 []int        // nil slice
s2 := []int{}       // empty slice (не nil!)
s3 := make([]int, 0) // empty slice (не nil!)

fmt.Println(s1 == nil) // true
fmt.Println(s2 == nil) // false
fmt.Println(s3 == nil) // false

fmt.Println(len(s1), len(s2), len(s3)) // 0 0 0 — все пустые!
```

**Различия:**
- `nil` slice: не аллоцирован, 0 аллокаций памяти
- Empty slice: аллоцирован в памяти

**На практике:** Почти всегда работают одинаково (append работает с обоими), но при JSON маршалинге:
- `nil` slice → `null` в JSON
- Empty slice → `[]` в JSON

**Идиоматично:** Предпочитай `var s []int` (nil) если не знаешь размер заранее.

---

## Сравнение слайсов

### Нельзя использовать ==

В Go **слайсы нельзя сравнивать через `==`** (кроме сравнения с `nil`):

```go
a := []int{1, 2, 3}
b := []int{1, 2, 3}

// a == b  // ❌ ОШИБКА КОМПИЛЯЦИИ: slice can only be compared to nil

a == nil  // ✅ OK (false)
var s []int
s == nil  // ✅ OK (true)
```

### Сравнение содержимого

**Вручную:**
```go
func equal(a, b []int) bool {
    if len(a) != len(b) {
        return false
    }
    for i := range a {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}
```

**Стандартная библиотека (Go 1.21+):**
```go
import "slices"

a := []int{1, 2, 3}
b := []int{1, 2, 3}
slices.Equal(a, b) // true

// Другие полезные функции
slices.Contains(nums, 30)  // true если 30 в nums
slices.Index(nums, 30)     // индекс элемента или -1
```

---

## Многомерные слайсы

```go
// Слайс слайсов (аналог ArrayList<ArrayList<Integer>>)
matrix := [][]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}

fmt.Println(matrix[1][2]) // 6
```

---

## Сравнение с Java: краткая таблица

| Операция | Go | Java |
|----------|-----|------|
| Массив фиксированной длины | `[5]int` | `int[5]` |
| Динамический массив | `[]int` | `ArrayList<Integer>` |
| Создание с capacity | `make([]int, 0, 10)` | `new ArrayList<>(10)` |
| Добавление элемента | `s = append(s, x)` | `list.add(x)` |
| Длина | `len(s)` | `list.size()` |
| Подмассив (view) | `s[1:4]` | `list.subList(1, 4)` |
| Независимая копия | `copy(dst, src)` | `new ArrayList<>(list)` |
| Итерация | `for i, v := range s` | `for (int v : list)` |
| Сравнение содержимого | `slices.Equal(a, b)` | `list.equals(other)` |
| Поиск элемента | `slices.Contains(s, x)` | `list.contains(x)` |

---

## Резюме

**Массивы:**
- Фиксированная длина, размер — часть типа
- Передаются по значению (копируются)
- Используются редко (в основном внутри слайсов)

**Слайсы:**
- Динамический view над массивом
- `append()` для добавления элементов (может реаллоцировать)
- `s[low:high]` создаёт view на тот же массив
- `copy()` для независимого копирования
- Нельзя сравнивать `==`, используй `slices.Equal()`

**Подводные камни:**
1. Slicing держит весь базовый массив в памяти
2. `append` может перезаписать другие слайсы (решение: `[:high:max]`)
3. `nil` slice ≠ empty slice (но обычно работают одинаково)

**Главная идея:** Слайсы — это лёгкий дескриптор над массивом. Понимание этого помогает избежать неожиданного поведения.
